# push_swap

## Задача

Написать программу на C, которая вычисляет и отображает в стандартном выводе наименьший набор инструкций для сортировки
int'ов.

## Инструкции

- Исполняемый файл должен называться *push_swap*
- Необходим Makefile с обычными правилами для компиляции проекта. Перекомпиляция должна происходить только в случае
  необходимости.
- Используем свою библиотеку libft (у библиотеки свой Makefile). Наш Makefile сначала компилирует библиотеку, а потом
  компилирует проект.
- Глобальные переменные запрещены.
- Проект должен быть написан на C в соответствии с *Norm*.
- Любые ошибки должны обрабатываться. Программа не должна завершаться неожиданым образом. Обязательно освобождение
  памяти.
- Утечки памяти запрещены.
- Разрешенные функции:
    - `write`
    - `read`
    - `malloc`
    - `free`
    - `exit`

## Основная часть

### Правила игры

- Игра состоит из двух стеков **a** и **b**
- В начале стека a содержит случайное количество отрицательных или положительных чисел, которые не могут повторяться.
  Стопка b пустая.
- Цель отсортировать их в порядке возрастания в стеке a.
- Для этого нам доступны следующие операции:
    0. **`sa` : swap a** - поменять местами первые два элемента в верхней части стека a. Ничего не делать, если есть
       только один элемент или нет элементов.
    1. **`sb` : swap b** - поменять местами первые два элемента в верхней части стека b. Ничего не делать, если есть
       только один элемент или нет элементов.
    2. **`ss` :** - sa и sb одновременно.
    3. **`pa` : push a** - взять первый элемент сверху стека b и положить его наверх стека a.Ничего не делать, если b
       пустая.
    4. **`pb` : push b** - взять первый элемент сверху стека a и положить его наверх стека b.Ничего не делать, если a
       пустая.
    5. **`ra` : rotate a** - сдвигаем вверх все элементы стека a на 1. Первый элемент становится последним.
    6. **`rb` : rotate b** - сдвигаем вверх все элементы стека b на 1. Первый элемент становится последним.
    7. **`rr` :** - ra и rb одновременно.
    8. **`rra` : reverse rotate a** - сдвигаем вниз все элементы стека a на 1. Последний элемент становится первым.
    9. **`rrb` : reverse rotate b** - сдвигаем вниз все элементы стека b на 1. Последний элемент становится первым.
    10. Последний элемент становится первым.
    11. **`rrr` :** rra и rrb одновременно.

## Программа *push_swap*

- Нужно написать программу с названием `push_swap`, которая получает как аргумент стек a в виде списка int'ов. Первый
  аргумент должен быть вершиной стека.
- Программа должна показать наименьший список операций для сортировки стека a (
  наименьшее значение стека a должно быть сверху).
- Операции должны быть разделены **только** переносом строки `\n`.
- Цель в том, чтобы отсортровать стек с минимально возможным колличеством операций. Во время защиты сравнивается
  количество операций с максимально допустимым значением. Если список операций слишком большой или список не
  отсортирован должным образом - **FAIL**.
- Если параметры не указаны, программа не должна ничего отображать и подсказывать.
- В случае ошибки дожна показать `Error` и `\n` за ним в стандартном потоке для ошибок. `Errors` включают для примера:
    - some arguments aren’t integers,
    - some arguments are bigger than an integer,
    - there are duplicates.
- Во время защиты push_swap будет проверена готовым чекером следующим образом:

`$>ARG="4 67 3 87 23"; ./push_swap $ARG | wc -l`

`6`

---

`$>ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker_OS $ARG`

`OK`

`$>`

Если программа **checker_OS** показывет **
KO**, наш push_swap завершился со списком операций, которые не сортируют стек.
---

## Валидация

### Аргумент только один:

`$>ARG="4 67 3 87 23"; ./push_swap $ARG`

`$>./push_swap "4 67 3 --87 23"` - раздель только пробел `char spac = 40 == ' ' `
`$>./push_swap "   4 67 3 87 23  "` - тоже валидный

* "12 34 54 5" - аргумент
    * "12" - элемент
        * 12 - число

Отбрасывать ошибку если:

- недопустимые символы ![ +-0-9]
- после каждого + и - должен быть числовой символ
- каждый элементы(набор цифр, может начинаться с одного + или -) переводится в Integer
    - должно быть больше чем один элемент в аргументе (потом проверим в структуре количество цифр)
    - каждый элемент не должен превышает границы Integer
    - каждое число должно быть уникальным

### Аргументов два и более:

`$>./push_swap 4 67 3 +87 23`

- недопустимые символы ![ +-0-9]
- после каждого + и - должен быть числовой символ
- каждый элементы(набор цифр, может начинаться с одного + или -) переводится в Integer
    - каждый элемент не должен превышает границы Integer
    - каждое число должно быть уникальным (TODO для этого нужно решить в какой структуре хранить стек)

---

### Функции для валидации:

```
int checkNextChar(char *str) - принимает указатель на символ и проверяет следующий после него
    if (*str == " ")
        *(str + 1) должен быть либо " " либо +/-  либо [0-9]
    ...
```

```
long atol(char *str) - atoi только с long чтобы проверить помещается число в Integer
```

```
List *convertArgsToList(char *string) - функция оборачивает работу функций выше 
и переводит строки/строку в односвязный список

typedef struct          s_list
{
	int             value;
	struct s_list	*next;
}		        t_list;

```

```
void	init_singleton(t_base *singleton, int argc, char **argv) - сохраняет параметры в лист.
```

---

## Алгоритм сортировки с подсчетом шагов для каждого элемента

### Термины (напрямую связаны с неймингом в коде)

* `sort` - сортированный стек/последовательность. Все элементы на своих места
* `presort` - предотсортированный стек/последовательность. Достаточно операций `rotatte` и `reverse rotate` чтобы стек стал `sort`
* `first` - самый большой элемент (первый)
* `last` - самый маленький элемент (последний)
* `sequence` - последовательность элементов стека
* `operations` - последовательность операций
* `A` - стек A
* `B` - стек B

### Последовательность

1. найти `first`, `last`, `size`
2. найти самую длинный `presort sequence` в `A`.
   1. записать `presort_head_value`, `presort_tail_value`, `presorted_size` для `presort sequence` в `A`.
3. скинуть все элементы которые не входят в `presort sequence` из `A` в `B`
   1. допустимые команды `ra`/`pb`
   1. пока `A->size` > `presort size`
      1. `ra` пока (`head->value` >= `presort_head_value` && `head->value` <= `presort tail_value` && `presorted_size` < `A->size`)
      2. `pb` пока (`head->value` < `presort_head_value` && `head->value` > `presort tail_value` && `presorted_size` < `A->size`)
5. перенести все элементы из `B` в `A` так чтобы `A` был всегда `presort`
   1. в цикле, пока `B` не пуст
      1. для каждого элемента `B` найти кратчайшую `operations`  
         1. допустимые команды `rb`/`rrb`/`pb`/`ra`/`rra`/`rrr`/`rr`/`pa`
            1. `A`↓ - `B`↑ - `A` ← `B`
            2. `A`↑ - `B`↓ - `A` ← `B`
            3. `A`↓ - `B`↓ - `A` ← `B`
               1. оптимизировать с учетом `rrr` и `rr`
            4. `A`↑ - `B`↑ - `A` ← `B`
               1. оптимизировать с учетом `rrr` и `rr`
      2. выбрать кратчайшую `operations`
      3. исполнить кратчайшую `operations`
      4. добавить в конец итоговой последовательность кратчайшую `operations` 
         1. `push back` кратчайшую `operations` в `singleton->operations`
6. распечатать
  
---

## Bugs and TODOs

* ```./push_shwap "1, 5"```
    * ```Process finished with exit code 1```
* ```./push_shwap```
    * ```Process finished with exit code 1```


