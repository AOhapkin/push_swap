# push_swap

## Задача

Написать программу на C, которая вычисляет и отображает в стандартном выводе наименьший набор инструкций для сортировки
int'ов.

## Инструкции

- Исполняемый файл должен называться *push_swap*
- Необходим Makefile с обычными правилами для компиляции проекта. Перекомпиляция должна происходить только в случае
  необходимости.
- Используем свою библиотеку libft (у библиотеки свой Makefile). Наш Makefile сначала компилирует библиотеку, а потом
  компилирует проект.
- Глобальные переменные запрещены.
- Проект должен быть написан на C в соответствии с *Norm*.
- Любые ошибки должны обрабатываться. Программа не должна завершаться неожиданым образом. Обязательно освобождение
  памяти.
- Утечки памяти запрещены.
- Разрешенные функции:
    - `write`
    - `read`
    - `malloc`
    - `free`
    - `exit`

## Основная часть

### Правила игры

- Игра состоит из двух стеков **a** и **b**
- В начале стека a содержит случайное количество отрицательных или положительных чисел, которые не могут повторяться.
  Стопка b пустая.
- Цель отсортировать их в порядке возрастания в стеке a.
- Для этого нам доступны следующие операции:
    0. **`sa` : swap a** - поменять местами первые два элемента в верхней части стека a. Ничего не делать, если есть
       только один элемент или нет элементов.
    1. **`sb` : swap b** - поменять местами первые два элемента в верхней части стека b. Ничего не делать, если есть
       только один элемент или нет элементов.
    2. **`ss` :** - sa и sb одновременно.
    3. **`pa` : push a** - взять первый элемент сверху стека b и положить его наверх стека a.Ничего не делать, если b
       пустая.
    4. **`pb` : push b** - взять первый элемент сверху стека a и положить его наверх стека b.Ничего не делать, если a
       пустая.
    5. **`ra` : rotate a** - сдвигаем вверх все элементы стека a на 1. Первый элемент становится последним.
    6. **`rb` : rotate b** - сдвигаем вверх все элементы стека b на 1. Первый элемент становится последним.
    7. **`rr` :** - ra и rb одновременно.
    8. **`rra` : reverse rotate a** - сдвигаем вниз все элементы стека a на 1. Последний элемент становится первым.
    9. **`rrb` : reverse rotate b** - сдвигаем вниз все элементы стека b на 1. Последний элемент становится первым.
    10. Последний элемент становится первым.
    11. **`rrr` :** rra и rrb одновременно.

## Программа *push_swap*

- Нужно написать программу с названием `push_swap`, которая получает как аргумент стек a в виде списка int'ов. Первый
  аргумент должен быть вершиной стека.
- Программа должна показать наименьший список операций для сортировки стека a (
  наименьшее значение стека a должно быть сверху).
- Операции должны быть разделены **только** переносом строки `\n`.
- Цель в том, чтобы отсортровать стек с минимально возможным колличеством операций. Во время защиты сравнивается
  количество операций с максимально допустимым значением. Если список операций слишком большой или список не
  отсортирован должным образом - **FAIL**.
- Если параметры не указаны, программа не должна ничего отображать и подсказывать.
- В случае ошибки дожна показать `Error` и `\n` за ним в стандартном потоке для ошибок. `Errors` включают для примера:
    - some arguments aren’t integers,
    - some arguments are bigger than an integer,
    - there are duplicates.
- Во время защиты push_swap будет проверена готовым чекером следующим образом:

`$>ARG="4 67 3 87 23"; ./push_swap $ARG | wc -l`

`6`

---

`$>ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker_OS $ARG`

`OK`

`$>`

Если программа **checker_OS** показывет **
KO**, наш push_swap завершился со списком операций, которые не сортируют стек.
---

## Валидация

### Аргумент только один:

`$>ARG="4 67 3 87 23"; ./push_swap $ARG`

`$>./push_swap "4 67 3 --87 23"` - раздель только пробел `char spac = 40 == ' ' `
`$>./push_swap "   4 67 3 87 23  "` - тоже валидный

* "12 34 54 5" - аргумент
    * "12" - элемент
        * 12 - число

Отбрасывать ошибку если:

- недопустимые символы ![ +-0-9]
- после каждого + и - должен быть числовой символ
- каждый элементы(набор цифр, может начинаться с одного + или -) переводится в Integer
    - должно быть больше чем один элемент в аргументе (потом проверим в структуре количество цифр)
    - каждый элемент не должен превышает границы Integer
    - каждое число должно быть уникальным

### Аргументов два и более:

`$>./push_swap 4 67 3 +87 23`

- недопустимые символы ![ +-0-9]
- после каждого + и - должен быть числовой символ
- каждый элементы(набор цифр, может начинаться с одного + или -) переводится в Integer
    - каждый элемент не должен превышает границы Integer
    - каждое число должно быть уникальным (TODO для этого нужно решить в какой структуре хранить стек)

---

### Функции для валидации:

```
int check_next_char(char *str) - принимает указатель на символ и проверяет следующий после него
    if (*str == " ")
        *(str + 1) должен быть либо " " либо +/-  либо [0-9]
    ...
```

```
long atol(char *str) - atoi только с long чтобы проверить помещается число в Integer
```

```
List *convertArgsToList(char *string) - функция оборачивает работу функций выше 
и переводит строки/строку в односвязный список

typedef struct          s_list
{
	int             value;
	struct s_list	*next;
}		        t_list;

```

```
void	init_singleton(t_base *singleton, int argc, char **argv) - сохраняет параметры в лист.
```

---

## Алгоритм сортировки с подсчетом шагов для каждого элемента

### Термины (напрямую связаны с неймингом в коде)

* `sort` - сортированный стек/последовательность. Все элементы на своих места
* `presort` - предотсортированный стек/последовательность. Достаточно операций `rotatte` и `reverse rotate` чтобы стек
  стал `sort`
* `A` - стек A
* `B` - стек B
* `*best` - элемент стека `B` который можно вставить в стек `A` наименьшими затратами

### Последовательность

1. в цикле из `pb` пока длина стека `A` не станет `3`
2. если `A` не `presort`
    1. один раз `sa` => `A` `presort`
3. сортировка вставкой из стека `B` в стек `A`
    1. пока стек `B` не опустеет
        1. в стеке `B` найти элемент `*best` который меньшими затратами можно вставить в стек `A` так, чтобы `A`
           оставался `presort`
            1. допустимые команды `rb`/`rrb`/`pb`/`ra`/`rra`/`rrr`/`rr`/`pa`
                1. `A`↓ - `B`↑ - `A` ← `B`
                2. `A`↑ - `B`↓ - `A` ← `B`
                3. `A`↓ - `B`↓ - `A` ← `B`
                    1. оптимизировать с учетом `rrr` и `rr`
                4. `A`↑ - `B`↑ - `A` ← `B`
                    1. оптимизировать с учетом `rrr` и `rr`
        2. вставить `*best` в `A` оптимальным набором команд
4. распечатать
